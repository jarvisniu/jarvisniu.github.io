/**
 * BjCvsMap-1.0
 * 地图显示引擎
 *
 *
 * 依赖 Dependence
 * ==============
 *
 * TileProvider(1.1-1.2, NOT 1.3)
 *
 *
 * 功能 Features
 * ============
 *
 * 1. 分级显示地图
 * 2. 多边形绘制
 * 3.
 *
 * ========================  Change Log  ==============================
 *
 *     v1.0.0
 *
 *         1. first release
 *
 *
 *     v1.0.1
 *
 *         1. sync to TileProvider
 *
 *
 * 计划 Plan
 * ========
 *
 * - 封装成模块
 * - 更名为 BjMap
 *
 */

// map environment
var level = 16;  // 初始缩放等级
var initCoord = { lat: 39.9158, lon: 116.3908 };  // 初始经纬度：紫禁城
var cIndex;
var zoomFactor = 1;  // zoom factor, from 0.5 to 1, used to generate smooth zoom animation.
var isZooming = 0;
var cvs, ctx, cvsW, cvsH, halfW, halfH, tileNumW, tileNumH;
var tileGetter;
var mousePos = { X: -1, Y: -1, GX: -1, GY: -1, Lng: -1, Lat: -1, DotIndex: -1, LineIndex: -1 };
var mouseDown = { X: 0, Y: 0, Button: -1, MovLength: 0 };
var indexSelectedPoint = -1;

// region data
var regions = [[]];
var selRegionIndex = 0;

// settings
var isZoomingSmooth = true;

function initCvsMap() {
    //debug

    // set uniform vars
    cIndex = {
        X: lon2index(initCoord.lon, level),
        Y: lat2index(initCoord.lat, level)
    };
    cvs = document.getElementsByTagName("canvas")[0];
    ctx = cvs.getContext("2d");
    ctx.textBaseline = "top";
    ctx.font = "13px SimSun";
    cvsW = cvs.width; cvsH = cvs.height;
    halfW = cvsW / 2; halfH = cvsH / 2;
    tileNumW = Math.ceil(cvsW / 256) + 2; tileNumH = Math.ceil(cvsH / 256) + 2;

    if (!("TileProvider" in window)) console.error("未找到TileProvider类，请检查是否未引用该库文件。");
    tileGetter = new TileProvider();
    tileGetter.set({
        source: MapSource.BING // 注释掉此句以使用Google Maps（但需要翻墙）
    });
    tileGetter.onProgress = drawCanvas;
    
    // bind event handlers
    cvs.addEventListener("mousemove", onMouseMove);
    cvs.addEventListener("mousedown", onMouseDown);
    cvs.addEventListener("mouseup", onMouseUp);
    cvs.addEventListener("mousewheel", onMouseWheel);
    document.addEventListener("keydown", onKeyDown);

    setTimeout(drawCanvas, 100);
}
document.addEventListener("DOMContentLoaded", initCvsMap);

// Drawing functions
function drawCanvas() {
    ctx.clearRect(0, 0, cvsW, cvsH);
    drawTiles();
    drawRegion();
    drawLevelInfo();
    drawMouseInfo();
}

function drawTiles() {
    var xFrom = parseInt(cIndex.X - tileNumW / 2);
    var xTo = xFrom + tileNumW;
    var yFrom = parseInt(cIndex.Y - tileNumH / 2);
    var yTo = yFrom + tileNumH;
    for(var i = xFrom; i <= xTo; i++) {
        for( var j = yFrom; j <= yTo; j++) {
            drawTile(i, j, level);
        }
    }
}

function drawTile(x, y, z) {
    var drawPos = {X: halfW, Y: halfH};
    drawPos.X += (x - cIndex.X) * 256 * zoomFactor;
    drawPos.Y += (y - cIndex.Y) * 256 * zoomFactor;
    var img = tileGetter.getDom(x, y, z);
    ctx.drawImage(img, drawPos.X, drawPos.Y, 256 * zoomFactor, 256 * zoomFactor);
}

function drawRegion() {
    for (var j in regions) {
        var region = regions[j];
        var isSel = (j == selRegionIndex);

        // region
        ctx.strokeStyle = "rgb(0, 128, 192)";
        ctx.fillStyle = (isSel ? 'rgba(192, 192, 192, 0.5)' : 'rgba(64, 64, 64, 0.5)');
        ctx.lineWidth = isSel ? 3 : 2;
        ctx.beginPath();
        for (var i in region)
        {
            ctx.lineTo(region[i].DrawingX,region[i].DrawingY);
        }
        ctx.stroke();
        ctx.fill();

        // close the loop
        if (region.length > 2) {
            ctx.lineWidth = 1;
            //ctx.strokeStyle = "rgb(100, 100, 200)";
            ctx.beginPath();
            ctx.lineTo(region[0].DrawingX,region[0].DrawingY);
            ctx.lineTo(region[region.length - 1].DrawingX,region[region.length - 1].DrawingY);
            ctx.stroke();
        }

        // control points
        if (isSel) {
            ctx.strokeStyle = "rgb(0, 100, 50)";
            ctx.fillStyle = "rgb(255, 255, 0)";
            ctx.lineWidth = 1;
            for(i in region) {
                if (i != mousePos.DotIndex) {
                    ctx.fillRect(region[i].DrawingX - 3,region[i].DrawingY - 3,6,6);
                } else {
                    ctx.fillStyle = "rgb(255, 0, 0)";
                    ctx.fillRect(region[i].DrawingX - 3,region[i].DrawingY - 3,6,6);
                    ctx.fillStyle = "rgb(255, 255, 0)";
                }
                if(i == indexSelectedPoint) {
                    ctx.strokeStyle = "rgb(255, 0, 0)";
                    ctx.lineWidth = 2;
                } else {
                    ctx.strokeStyle = "rgb(0, 100, 50)";
                    ctx.lineWidth = 1;
                }
                ctx.strokeRect(region[i].DrawingX - 3,region[i].DrawingY - 3,6,6);
            }

            // mouse hover on line
            ctx.fillStyle = "rgb(255, 128, 0)";
            ctx.strokeStyle = "rgb(0, 100, 50)";
            if(mousePos.DotIndex == -1 && mousePos.LineIndex > -1) {
                ctx.fillRect(mousePos.X - 3, mousePos.Y - 3,6,6);
                ctx.strokeRect(mousePos.X - 3, mousePos.Y - 3,6,6);
            }
        }
    }
}

function drawLevelInfo() {
    ctx.strokeStyle = "rgb(0, 0, 0)";
    ctx.strokeRect(8, 8, 80, 18);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.fillRect(8, 8, 80, 18);
    ctx.fillStyle = "#222";
    ctx.fillText("Level = " + level, 13, 11);
}

function drawMouseInfo() {
    ctx.strokeStyle = "rgb(0, 0, 0)";
    ctx.strokeRect(mousePos.X, mousePos.Y + 20, 188, 17);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.fillRect(mousePos.X, mousePos.Y + 20, 188, 17);
    ctx.fillStyle = "#222";
    ctx.fillText("X：" + r5(mousePos.Lng), mousePos.X + 4, mousePos.Y + 22);
    ctx.fillText("Y：" + r5(mousePos.Lat), mousePos.X + 100, mousePos.Y + 22);
}

// Mouse event functions
function onMouseMove(e) {
    mousePos.X = e.offsetX;
    mousePos.Y = e.offsetY;
    mousePos.Lng = index2lon(mousePos.GX, level, 6);
    mousePos.Lat = index2lat(mousePos.GY, level, 6);
    mousePos.GX = cIndex.X + (mousePos.X - halfW) / 256;
    mousePos.GY = cIndex.Y + (mousePos.Y - halfH) / 256;

    if (mouseDown.Button == -1) {
        mousePos.DotIndex = getHoverDotIndex();
        if (mousePos.DotIndex == -1) {
            mousePos.LineIndex = getHoverLineIndex();
        }
    } else if (mouseDown.Button == 0) {
        var deltaX = mousePos.X - mouseDown.X;
        var deltaY = mousePos.Y - mouseDown.Y;
        if(mousePos.DotIndex == -1) {
            cIndex.X -= deltaX / 256;
            cIndex.Y -= deltaY / 256;
            mouseDown.MovLength += Math.abs(deltaX) + Math.abs(deltaY);
            reCalcDrawingPos();
        } else {
            var point = regions[selRegionIndex][mousePos.DotIndex];
            point.DrawingX += deltaX;
            point.DrawingY += deltaY;
            point.GX = drawX2gX(point.DrawingX);
            point.GY = drawY2gY(point.DrawingY);
            point.Lng = index2lon(point.GX, level);
            point.Lat = index2lat(point.GY, level);
            showPoints();
        }
    } else if (mouseDown.Button == 1) {
        mouseDown.MovLength += Math.abs(deltaX) + Math.abs(deltaY);
        
    } else if (mouseDown.Button == 2) {
        mouseDown.MovLength += Math.abs(deltaX) + Math.abs(deltaY);
        
    }

    // cursor
    if(mousePos.DotIndex == -1 && mousePos.LineIndex == -1) {
        cvs.style.cursor = "default";
    } else {
        cvs.style.cursor = "hand";
    }
    mouseDown.X = e.offsetX;
    mouseDown.Y = e.offsetY;
    drawCanvas();
}

function onMouseDown(e) {
    mouseDown.Button = e.button;

    if(mousePos.DotIndex == -1) {
        if (mousePos.LineIndex > -1) {
            mousePos.DotIndex = mousePos.LineIndex + 1;
            addPoint(mousePos.Lng, mousePos.Lat, mousePos.LineIndex + 1);
            drawCanvas();
        }   
    }
}

function onMouseUp(e) {
    // 左键未移动松开添加点
    if (mouseDown.Button == 0 && mouseDown.MovLength < 8 & regions.length > 0) {
        if(mousePos.DotIndex < 0) {
            addPoint(mousePos.Lng, mousePos.Lat);
            indexSelectedPoint = regions[selRegionIndex].length - 1;
        } else {
            indexSelectedPoint = mousePos.DotIndex;
        }
    }

    mouseDown.Button = -1;
    mouseDown.MovLength = 0;
}

function onKeyDown(e) {
    //document.title = e.keyCode;
    if(e.keyCode == 46 && indexSelectedPoint > -1) {
        regions[selRegionIndex].splice(indexSelectedPoint, 1);
        indexSelectedPoint = -1;
        showPoints();
        mousePos.LineIndex = -1;
        mousePos.DotIndex = -1;
        drawCanvas();
        cvs.style.cursor = "default";
    }
}

function onMouseWheel(e) {
    // 左键未移动松开
    if (e.wheelDelta > 0) {
        if (isZoomingSmooth)
            zoomInSmooth();
        else
            zoomIn();
    } else {
        if (isZoomingSmooth)
            zoomOutSmooth();
        else
            zoomOut();
    }
}

function addPoint(lng, lat, idx) {
    var gx = lon2index(lng, level);
    var gy = lat2index(lat, level);
    var p = {
        Lng: lng,
        Lat: lat,
        GX: gx,
        GY: gy,
        DrawingX: gX2DrawX(gx),
        DrawingY: gY2DrawY(gy)
    };
    if (idx == undefined)
        regions[selRegionIndex].push(p);
    else{
        regions[selRegionIndex].splice(idx, 0, p);
    }
    showPoints();
}

function navigateTo(lat, lon) {
    var x = lon2index(lon, level);
    var y = lat2index(lat, level);
    cIndex.X = x;
    cIndex.Y = y;
    //alert(cIndex.X+"\n"+cIndex.Y);
    reCalcDrawingPos();
    drawCanvas();
}

// GeoMath
function gX2DrawX(gx) {
    return halfW + (gx - cIndex.X) * 256 * zoomFactor;
}

function gY2DrawY(gy) {
    return halfH + (gy - cIndex.Y) * 256 * zoomFactor;
}

function drawX2gX(drawX) {
    return (drawX - halfW) / 256 + cIndex.X;
}

function drawY2gY(drawY) {
    return (drawY - halfH) / 256 + cIndex.Y;
}

function getHoverLineIndex() {
    if (regions.length == 0) return -1;
    if (regions[selRegionIndex].length < 2) return -1;
    for(var i in regions[selRegionIndex]) {
        var nextI = parseInt(i) + 1;
        if (nextI == regions[selRegionIndex].length) nextI = 0;
        if(isPointOnLine(mousePos.X, mousePos.Y, 
            regions[selRegionIndex][i].DrawingX, regions[selRegionIndex][i].DrawingY,
            regions[selRegionIndex][nextI].DrawingX, regions[selRegionIndex][nextI].DrawingY))
            return parseInt(i);
    }
    return -1;
}

function isPointOnLine(x, y, p1x, p1y, p2x, p2y) {
    var a = (p1y - p2y) / (p1x - p2x);
    var b = p1y - (p1y - p2y) * p1x / (p1x - p2x);
    var czX = (y + x / a - b) / (a + 1 / a);
    var czY = a * czX + b;
    var len1 = bevel(czX - x, czY - y);
    var cp = centralP(p1x, p1y, p2x, p2y);
    var k = (p2y - p1y) / (p2x - p1x);
    var len2 = p2l_pk(x, y, cp[0], cp[1], -1 / k);
    return (len1 < 5 && len2 * 2 < bevel(p2y - p1y, p2x - p1x));
}

function p2l_2p(x, y, p1x, p1y, p2x, p2y) {
    var a = (p1y - p2y) / (p1x - p2x);
    var b = p1y - (p1y - p2y) * p1x / (p1x - p2x);
    var czX = (y + x / a - b) / (a + 1 / a);
    var czY = a * czX + b;
    return bevel(czX - x, czY - y);
}

function p2l_kb(x, y, k, b) {
    var czX = (y + x / k - b) / (k + 1 / k);
    var czY = (k * y + x + b / k) / (k + 1 / k);
    return bevel(czX - x, czY - y);
}

function p2l_pk(x, y, x0, y0, k) {
    var czX = (y + x / k + k * x0 - y0) / (k + 1 / k);
    var czY = (k * y + x + k * k * x0 - y0 * k) / (k + 1 / k) - k * x0 + y0;
    return bevel(czX - x, czY - y);
}

function bevel(x, y) {
    return Math.sqrt(x*x + y*y);
}

function centralP(x1, y1, x2, y2) {
    return [(x1 + x2) / 2, (y1 + y2) / 2];
}

function getHoverDotIndex() {
    for(i in regions[selRegionIndex]) {
        if (Math.abs(mousePos.X - regions[selRegionIndex][i].DrawingX) < 4
         && Math.abs(mousePos.Y - regions[selRegionIndex][i].DrawingY) < 4)
            return i;
    }
    return -1;
}

function reCalcGPos() {
    for(j in regions) {
        for(i in regions[j]) {
            regions[j][i].GX = lon2index(regions[j][i].Lng, level);
            regions[j][i].GY = lat2index(regions[j][i].Lat, level);
        } 
    }
}

function reCalcDrawingPos() {
    for (i in regions) {
        for(j in regions[i]) {
            regions[i][j].DrawingX = gX2DrawX(regions[i][j].GX);
            regions[i][j].DrawingY = gY2DrawY(regions[i][j].GY);
        }
    }
}

function showPoints() {
    var str = "";
    for(i in regions[selRegionIndex]) {
        str += "P" + i + ": [" + r5(regions[selRegionIndex][i].Lng) + ", " + r5(regions[selRegionIndex][i].Lat) + "]\n";
    }
    document.getElementsByTagName("textarea")[0].value = str;
}

function clearAll() {
    regions.length = 0;
    drawCanvas();
    showPoints();
}

function switchRegion(i) {
    selRegionIndex = i;
    showPoints();
    drawCanvas();
}

function addRegion() {
    regions.push([]);

    switchRegion(regions.length - 1);
    showRegionButtons();
}

function removeSelRegion() {
    regions.splice(selRegionIndex, 1);
    // selRegionIndex 尽量保持不变，即选择后一个
    // 但是当删除的就是最后一个时，前一一个
    if(selRegionIndex == regions.length) selRegionIndex --;
    // 再但是删除前就是唯一的原色，那么也不能前移了。但凑巧前移以后为-1，在本程序中约定-1是合理的取值，意为：未选择。

    switchRegion(regions.length - 1);
    showRegionButtons();
}

function zoomOutSmooth() {
    if (isZooming == 1) return;
    isZooming = -1;
    zoomFactor *= 0.90;

    if (zoomFactor > 0.5)
        setTimeout(zoomOutSmooth, 20);
    else {
        zoomFactor = 1;
        isZooming = 0;
        level --;
        cIndex.X /= 2;
        cIndex.Y /= 2;
        reCalcGPos();
    }

    reCalcDrawingPos();
    drawCanvas();
}

function zoomInSmooth() {
    if (isZooming == -1) return;
    isZooming = 1;
    zoomFactor /= 0.90;

    if (zoomFactor < 2)
        setTimeout(zoomInSmooth, 20);
    else {
        zoomFactor = 1;
        isZooming = 0;
        level ++;
        cIndex.X *= 2;
        cIndex.Y *= 2;
        reCalcGPos();
    }

    reCalcDrawingPos();
    drawCanvas();
}

function zoomOut() {
    level --;
    cIndex.X /= 2;
    cIndex.Y /= 2;
    reCalcGPos();
    reCalcDrawingPos();
    drawCanvas();
}

function zoomIn() {
    level ++;
    cIndex.X *= 2;
    cIndex.Y *= 2;
    reCalcGPos();
    reCalcDrawingPos();
    drawCanvas();
}