var svgEle;				 				// 指南针在页面上的svg Element
var cpsMat=[];			 				// 对指南针进行投射投影的矩阵
var angleX=angleZ=0; 					// 内部角度变量，与外部角度数据交换的接口
var cpsPnts=[], polys=[];				// 指南针的顶点和面
var mouseDown={btn: -1, X: 0, Y: 0};	// 记录鼠标信息

function InitCompass() {
	var i, polyEle;
	var pointData=[ 4,0,0, -4,0,0, 0,12,0, 0,-12,0 ];
    for(i=0; i<32; i++){
        pointData.push(Math.cos(0.19634954*i)*15,Math.sin(0.19634954*i)*15,0);
    }
	var polyPosData=[[111], [0, 1, 2], [0, 1, 3]];
	for(i=0;i<32;i++)polyPosData[0][i]=i + 4;
	var polyColorData=["#06B", "#CCC", "#F00"];
	var polyColorDataBack=["#036", "#555", "#800"];

	document.body.innerHTML += '<svg id="compass" width="128px" height="128px" style="'
		+'position: absolute; left:20px; top: 20px; cursor: move;"></svg>';
	svgEle=document.getElementsByTagName("svg")[0];

	for (i=0; i<pointData.length; i+=3)
		cpsPnts[i/3]={X: pointData[i],Y: pointData[i+1],Z: pointData[i+2]};

	for (i in polyPosData) {
		polyEle=document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
		polyEle.setAttribute("style", "stroke: black; fill: "+polyColorData[i]+";");
		svgEle.appendChild(polyEle);

		polys[i]={
			PointIndexes: polyPosData[i],
			DOMEle: polyEle,
			DOMStyleFront: polyEle.getAttribute("style"),
			DOMStyleBack: "stroke: black; fill: "+polyColorDataBack[i]+";"
		};
	}
	svgEle.addEventListener("mousedown", function(e) {
		mouseDown.btn=e.button;
		mouseDown.X=e.offsetX;
		mouseDown.Y=e.offsetY;
	});
	svgEle.addEventListener("mousemove", function(e) {
		if(mouseDown.btn>-1) {
			angleZ += (e.offsetX - mouseDown.X)/40;
			mouseDown.X=e.offsetX;
			angleX += (e.offsetY - mouseDown.Y)/40;
			mouseDown.Y=e.offsetY;
			DrawCompass();

	        if ("pMatrixInfo" in window) {
                pMatrixInfo.RotateZ = angleZ * 180 / Math.PI;
	            pMatrixInfo.RotateX = angleX * 180 / Math.PI;
	        }
            needRender = true;
		}
	});
	svgEle.addEventListener("mouseup", function(e) {
		mouseDown.btn=-1;
	});
    if ("pMatrixInfo" in window) SyncCompass(pMatrixInfo.RotateX, pMatrixInfo.RotateZ);
	DrawCompass();
}
document.addEventListener("DOMContentLoaded", InitCompass);

function SyncCompass(rX, rZ) {
    angleX = rX * Math.PI / 180;
    angleZ = rZ * Math.PI / 180;
    DrawCompass();
}

function DrawCompass()
{
	var i, str, pi, pnt2D=Array();
	mat4.perspective(45, 1, 0.1, 1000, cpsMat);
    mat4.translate(cpsMat,[0, 0, 40]);
	mat4.rotate(cpsMat,angleX,[1, 0, 0]);
	mat4.rotate(cpsMat,angleZ,[0, 0, 1]);
	for(i in cpsPnts)pnt2D[i]=projectCpsPnt(cpsPnts[i]);

	for(i=0; i<polys.length; i++)
		polys[i].DOMEle.setAttribute("style", (Math.sin(angleX+Math.PI/2)>0) ? polys[i].DOMStyleFront : polys[i].DOMStyleBack);

	for(i=0; i<polys.length; i++) {
		str="";
		pi=polys[i].PointIndexes;
		for (j in pi) str += (j?" ":"")+pnt2D[pi[j]].X+","+pnt2D[pi[j]].Y;
		polys[i].DOMEle.setAttribute("points", str);
	}
}

function projectCpsPnt(point)
{
	var x, y, z, v4;
    v4=[point.X, point.Y, point.Z, 1];
    mat4.multiplyVec4(cpsMat, v4);
    x=v4[0]*64/v4[3]+64;
    y=-v4[1]*64/v4[3]+64;
    z=v4[2];
    return {X: x, Y: y, Z: z};
}