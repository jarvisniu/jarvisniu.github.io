// Generated by CoffeeScript 1.10.0
var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Bu.Renderer = (function() {
  var POINT_SIZE;

  POINT_SIZE = 4;

  function Renderer() {
    this.drawShapes = bind(this.drawShapes, this);
    this.toggle = bind(this.toggle, this);
    this["continue"] = bind(this["continue"], this);
    this.pause = bind(this.pause, this);
    var _self, clearCanvas, onResize, options, tick, tickCount;
    Za.EventListenerPattern.apply(this);
    this.type = "Renderer";
    _self = this;
    options = Bu.combineOptions(arguments, {
      width: 800,
      height: 600,
      fps: 60,
      fillParent: false,
      border: true
    });
    this.width = options.width;
    this.height = options.height;
    this.fps = options.fps;
    this.container = options.container;
    this.isDrawVertexes = true;
    this.dom = document.createElement("canvas");
    this.context = this.dom.getContext("2d");
    this.context.textBaseline = 'top';
    if (typeof ClipMeter !== "undefined" && ClipMeter !== null) {
      this.clipMeter = new ClipMeter();
    }
    this.shapes = [];
    if (options.fillParent) {

    } else {
      this.dom.width = this.width;
      this.dom.height = this.height;
      this.dom.style.width = this.width + "px";
      this.dom.style.height = this.height + "px";
    }
    if ((options.border != null) && options.border) {
      this.dom.style.border = "solid 1px gray";
    }
    this.dom.style.cursor = "crosshair";
    this.dom.style.background = "#eee";
    this.dom.oncontextmenu = (function(_this) {
      return function() {
        return false;
      };
    })(this);
    window.canvas = this.dom;
    onResize = function(e) {
      var canvasRatio, containerRatio, height, width;
      canvasRatio = _self.dom.height / _self.dom.width;
      containerRatio = _self.container.clientHeight / _self.container.clientWidth;
      if (containerRatio < canvasRatio) {
        height = _self.container.clientHeight;
        width = height / containerRatio;
      } else {
        width = _self.container.clientWidth;
        height = width * containerRatio;
      }
      _self.width = _self.dom.width = width;
      _self.height = _self.dom.height = height;
      _self.dom.style.width = width + 'px';
      return _self.dom.style.height = height + 'px';
    };
    window.addEventListener("resize", onResize);
    this.dom.addEventListener('DOMNodeInserted', onResize);
    tick = (function(_this) {
      return function() {
        if (!_self.isRunning) {
          return;
        }
        if (_this.clipMeter != null) {
          _self.clipMeter.start();
        }
        tickCount += 1;
        _self.triggerEvent("update", {
          "tickCount": tickCount
        });
        clearCanvas();
        _self.drawShapes();
        if (_this.clipMeter != null) {
          return _self.clipMeter.tick();
        }
      };
    })(this);
    setInterval(tick, 1000 / this.fps);
    clearCanvas = (function(_this) {
      return function() {
        return _this.context.clearRect(0, 0, _self.width, _self.height);
      };
    })(this);
    if (this.container != null) {
      if (typeof this.container === "string") {
        this.container = document.querySelector(this.container);
      }
      this.container.appendChild(this.dom);
    }
    tickCount = 0;
    this.isRunning = true;
  }

  Renderer.prototype.pause = function() {
    return this.isRunning = false;
  };

  Renderer.prototype["continue"] = function() {
    return this.isRunning = true;
  };

  Renderer.prototype.toggle = function() {
    return this.isRunning = !this.isRunning;
  };

  Renderer.prototype.append = function(shape) {
    return this.shapes.push(shape);
  };

  Renderer.prototype.drawShapes = function() {
    var j, len1, ref, results, shape;
    ref = this.shapes;
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      shape = ref[j];
      switch (shape.type) {
        case "Point":
          results.push(this.drawPoint(shape));
          break;
        case "Line":
          results.push(this.drawLine(shape));
          break;
        case "Circle":
          results.push(this.drawCircle(shape));
          break;
        case "Triangle":
          results.push(this.drawTriangle(shape));
          break;
        case "Rectangle":
          results.push(this.drawRectangle(shape));
          break;
        case "Fan":
          results.push(this.drawFan(shape));
          break;
        case "Bow":
          results.push(this.drawBow(shape));
          break;
        case "Polygon":
          results.push(this.drawPolygon(shape));
          break;
        case "Polyline":
          results.push(this.drawPolyline(shape));
          break;
        case "PointText":
          results.push(this.drawPointText(shape));
          break;
        case "Image":
          results.push(this.drawImage(shape));
          break;
        case "Bounds":
          results.push(this.drawBounds(shape));
          break;
        default:
          results.push(console.log("drawShapes(): unknown shape: ", shape));
      }
    }
    return results;
  };

  Renderer.prototype.drawPoint = function(shape) {
    var style;
    this.context.globalAlpha = shape.opacity;
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fillRect(shape.x - POINT_SIZE / 2, shape.y - POINT_SIZE / 2, POINT_SIZE, POINT_SIZE);
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.strokeRect(shape.x - POINT_SIZE / 2, shape.y - POINT_SIZE / 2, POINT_SIZE, POINT_SIZE);
    }
    if (shape.label != null) {
      style = this.context.fillStyle;
      this.context.fillStyle = "black";
      this.context.fillText(shape.label, shape.x - POINT_SIZE / 2 + 9, shape.y - POINT_SIZE / 2 + 6);
      return this.context.fillStyle = style;
    }
  };

  Renderer.prototype.drawVertexes = function(points) {
    var j, len1, point, results;
    if (this.isDrawVertexes) {
      results = [];
      for (j = 0, len1 = points.length; j < len1; j++) {
        point = points[j];
        results.push(this.drawPoint(point));
      }
      return results;
    }
  };

  Renderer.prototype.drawLine = function(shape) {
    this.context.globalAlpha = shape.opacity;
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      if (shape.dashStyle) {
        this.context.dashedLine(shape.points[0].x, shape.points[0].y, shape.points[1].x, shape.points[1].y, shape.dashStyle, shape.dashDelta);
      } else {
        this.context.beginPath();
        this.context.lineTo(shape.points[0].x, shape.points[0].y);
        this.context.lineTo(shape.points[1].x, shape.points[1].y);
        this.context.closePath();
      }
      this.context.stroke();
    }
    return this.drawVertexes(shape.points);
  };

  Renderer.prototype.drawCircle = function(shape) {
    this.context.globalAlpha = shape.opacity;
    this.context.beginPath();
    this.context.arc(shape.cx, shape.cy, shape.radius, 0, Math.PI * 2);
    this.context.closePath();
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fill();
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      this.context.stroke();
    }
    return this.drawPoint(shape.center);
  };

  Renderer.prototype.drawTriangle = function(shape) {
    var pts;
    this.context.globalAlpha = shape.opacity;
    this.context.beginPath();
    this.context.lineTo(shape.points[0].x, shape.points[0].y);
    this.context.lineTo(shape.points[1].x, shape.points[1].y);
    this.context.lineTo(shape.points[2].x, shape.points[2].y);
    this.context.closePath();
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fill();
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      if (shape.dashStyle) {
        this.context.beginPath();
        pts = shape.points;
        this.context.dashedLine(pts[0].x, pts[0].y, pts[1].x, pts[1].y, shape.dashStyle, shape.dashDelta);
        this.context.dashedLine(pts[1].x, pts[1].y, pts[2].x, pts[2].y, shape.dashStyle, shape.dashDelta);
        this.context.dashedLine(pts[2].x, pts[2].y, pts[0].x, pts[0].y, shape.dashStyle, shape.dashDelta);
      }
      this.context.stroke();
    }
    return this.drawVertexes(shape.points);
  };

  Renderer.prototype.drawRectangle = function(shape) {
    var xL, xR, yB, yT;
    this.context.globalAlpha = shape.opacity;
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fillRect(shape.position.x, shape.position.y, shape.size.width, shape.size.height);
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      if (!shape.dashStyle) {
        this.context.strokeRect(shape.position.x, shape.position.y, shape.size.width, shape.size.height);
      } else {
        this.context.beginPath();
        xL = shape.position.x;
        xR = shape.pointRB.x;
        yT = shape.position.y;
        yB = shape.pointRB.y;
        this.context.dashedLine(xL, yT, xR, yT, shape.dashStyle, shape.dashDelta);
        this.context.dashedLine(xR, yT, xR, yB, shape.dashStyle, shape.dashDelta);
        this.context.dashedLine(xR, yB, xL, yB, shape.dashStyle, shape.dashDelta);
        this.context.dashedLine(xL, yB, xL, yT, shape.dashStyle, shape.dashDelta);
        this.context.stroke();
      }
    }
    return this.drawVertexes(shape.points);
  };

  Renderer.prototype.drawFan = function(shape) {
    this.context.globalAlpha = shape.opacity;
    this.context.beginPath();
    this.context.arc(shape.cx, shape.cy, shape.radius, shape.aFrom, shape.aTo);
    this.context.lineTo(shape.cx, shape.cy);
    this.context.closePath();
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fill();
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      this.context.stroke();
    }
    return this.drawVertexes(shape.string.points);
  };

  Renderer.prototype.drawBow = function(shape) {
    this.context.globalAlpha = shape.opacity;
    this.context.beginPath();
    this.context.arc(shape.cx, shape.cy, shape.radius, shape.aFrom, shape.aTo);
    this.context.closePath();
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fill();
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      this.context.stroke();
    }
    return this.drawVertexes(shape.string.points);
  };

  Renderer.prototype.drawPolygon = function(shape) {
    var i, j, k, len, len1, point, pts, ref, ref1;
    this.context.globalAlpha = shape.opacity;
    this.context.beginPath();
    ref = shape.points;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      point = ref[j];
      this.context.lineTo(point.x, point.y);
    }
    this.context.closePath();
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fill();
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      len = shape.points.length;
      if (shape.dashStyle && len > 0) {
        this.context.beginPath();
        pts = shape.points;
        for (i = k = 0, ref1 = len - 1; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
          this.context.dashedLine(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, shape.dashStyle, shape.dashDelta);
        }
        this.context.dashedLine(pts[len - 1].x, pts[len - 1].y, pts[0].x, pts[0].y, shape.dashStyle, shape.dashDelta);
        this.context.stroke();
      }
      this.context.stroke();
    }
    return this.drawVertexes(shape.points);
  };

  Renderer.prototype.drawPolyline = function(shape) {
    var i, j, k, len1, point, pts, ref, ref1;
    if (shape.strokeStyle != null) {
      this.context.globalAlpha = shape.opacity;
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      this.context.beginPath();
      if (!shape.dashStyle) {
        ref = shape.points;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          point = ref[j];
          this.context.lineTo(point.x, point.y);
        }
      } else {
        pts = shape.points;
        for (i = k = 0, ref1 = pts.length - 1; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
          this.context.dashedLine(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, shape.dashStyle, shape.dashDelta);
        }
      }
      this.context.stroke();
    }
    return this.drawVertexes(shape.points);
  };

  Renderer.prototype.drawPointText = function(shape) {
    this.context.globalAlpha = shape.opacity;
    this.context.textAlign = shape.textAlign;
    this.context.textBaseline = shape.textBaseline;
    this.context.font = shape.font;
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      this.context.strokeText(shape.text, shape.x, shape.y);
    }
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      return this.context.fillText(shape.text, shape.x, shape.y);
    }
  };

  Renderer.prototype.drawImage = function(shape) {
    var dx, dy, h, w;
    if (shape.loaded) {
      this.context.save();
      this.context.globalAlpha = shape.opacity;
      w = shape.size.width * shape.scale.x;
      h = shape.size.height * shape.scale.y;
      dx = -w * shape.pivot.x;
      dy = -h * shape.pivot.y;
      this.context.translate(shape.position.x, shape.position.y);
      this.context.rotate(shape.rotation);
      this.context.drawImage(shape.image, dx, dy, w, h);
      return this.context.restore();
    }
  };

  Renderer.prototype.drawBounds = function(bounds) {
    this.context.strokeStyle = bounds.strokeStyle;
    this.context.beginPath();
    this.context.dashedLine(bounds.x1, bounds.y1, bounds.x2, bounds.y1, bounds.dashStyle, bounds.dashDelta);
    this.context.dashedLine(bounds.x2, bounds.y1, bounds.x2, bounds.y2, bounds.dashStyle, bounds.dashDelta);
    this.context.dashedLine(bounds.x2, bounds.y2, bounds.x1, bounds.y2, bounds.dashStyle, bounds.dashDelta);
    this.context.dashedLine(bounds.x1, bounds.y2, bounds.x1, bounds.y1, bounds.dashStyle, bounds.dashDelta);
    return this.context.stroke();
  };

  return Renderer;

})();

((function(_this) {
  return function() {
    var CP;
    CP = window.CanvasRenderingContext2D && CanvasRenderingContext2D.prototype;
    if (CP.lineTo != null) {
      return CP.dashedLine = function(x, y, x2, y2, da, delta) {
        var dc, di, draw, dx, dy, i, j, len, len1, lenU, rot;
        if (da == null) {
          da = Bu.DEFAULT_DASH_STYLE;
        }
        if (delta == null) {
          delta = 0;
        }
        this.save();
        dx = x2 - x;
        dy = y2 - y;
        len = Math.bevel(dx, dy);
        rot = Math.atan2(dy, dx);
        this.translate(x, y);
        this.rotate(rot);
        dc = da.length;
        di = 0;
        draw = true;
        lenU = 0;
        for (j = 0, len1 = da.length; j < len1; j++) {
          i = da[j];
          lenU += i;
        }
        delta %= lenU;
        x = delta;
        this.moveTo(0, 0);
        while (len > x) {
          di += 1;
          x += da[di % dc];
          if (x > len) {
            x = len;
          }
          if (draw) {
            this.lineTo(x, 0);
          } else {
            this.moveTo(x, 0);
          }
          draw = !draw;
        }
        this.restore();
        return this;
      };
    }
  };
})(this))();

//# sourceMappingURL=Renderer.js.map
