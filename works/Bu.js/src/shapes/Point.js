// Generated by CoffeeScript 1.10.0
var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Bu.Point = (function(superClass) {
  extend(Point, superClass);

  function Point(x1, y1) {
    this.x = x1 != null ? x1 : 0;
    this.y = y1 != null ? y1 : 0;
    this.clone = bind(this.clone, this);
    Point.__super__.constructor.call(this);
    this.stroke(false);
    this.type = "Point";
    this.label = null;
  }

  Point.prototype.arcTo = function(radius, arc) {
    return new Bu.Point(this.x + Math.cos(arc) * radius, this.y + Math.sin(arc) * radius);
  };

  Point.prototype.clone = function() {
    return new Bu.Point(this.x, this.y);
  };

  Point.prototype.copy = function(point) {
    this.x = point.x;
    return this.y = point.y;
  };

  Point.prototype.set = function(x, y) {
    this.x = x;
    return this.y = y;
  };

  Point.prototype.distanceTo = function(point) {
    return Math.bevel(this.x - point.x, this.y - point.y);
  };

  Point.prototype.isNear = function(target, limit) {
    var verticalDist;
    if (limit == null) {
      limit = Bu.DEFAULT_NEAR_DIST;
    }
    switch (target.type) {
      case "Point":
        return this.distanceTo(target) < limit;
      case "Line":
        verticalDist = target.distanceTo(this);
        return verticalDist < limit;
    }
  };

  return Point;

})(Bu.Object2D);

Bu.Point.interpolate = function(p1, p2, k, p3) {
  var x, y;
  x = p1.x + (p2.x - p1.x) * k;
  y = p1.y + (p2.y - p1.y) * k;
  if (p3 != null) {
    return p3.set(x, y);
  } else {
    return new Bu.Point(x, y);
  }
};

//# sourceMappingURL=Point.js.map
