// Generated by CoffeeScript 2.1.0
(function() {
  /*
   * A* computing engine
   *
   * Algorithm:
   *   1. Create a open list that contains the nodes that can be reached, initially only start node;
   *   2. Expand the list by adding neighbours of the node whose "f" is smallest;
   *   3. The neighbours must not in open list, closed list and not be obstacle;
   *   4. Move this node to the closed list;
   *   5. Calculate the "g", "h", "f" of the new added nodes;
   *   6. Resort the open list by "f";
   *   7. Loop from step 2 to 6 until the expanded nodes contains the end node or the open list is empty.
   *
   * Means of "g", "h", "f":
   *   1. g: distance that has gone
   *   2. h: shortest distance to the destination
   *   3. f: g + h
   *
   * API:
   *   finished: bool - Whether the algorithm is finished
   *   isRunning: bool - Whether the algorithm is running
   *   fps: bool - AutoStep speed
   *   result: Object - The result of resolving
   *     success: bool - Whether reach the end
   *     time: number - Elapsed time used to solve the process
   *     step: int - Steps used in the
   *   init() - Init the variables
   *   step() - Next step of solving
   *   run(fps) - Run the algorithm. If the parameter fps is given, the process will be animated.
   *
   *
   * Events:
   *   nodeChanged: a node state is changed, dedicated to refresh the UI
   *   finished: the algorithm is finished, no matter if success
   */
  var hasProp = {}.hasOwnProperty;

  AStar.Engine = class Engine {
    constructor(net) {
      var _end, _net, _step, autoStep, compareNodes, listClose, listOpen, nodeId, recalculateLastNode, startTime, stepCount, traceShortestPath;
      Bu.Event.apply(this);
      _net = net;
      this.finished = false;
      this.isRunning = false;
      this.fps = 10;
      listOpen = [];
      listClose = [];
      nodeId = 0; // Add an id to every node for comparing when their "f" is equal: recent node is prior.
      startTime = 0;
      stepCount = 0;
      this.result = {};
      this.init = () => {
        var i, j, k, l, node, ref, ref1, ref2;
        // for node in listClose
        // 	node.state = AStar.NODE_STATE_DEFAULT
        // 	node.prevNode = null
        // 	@trigger 'nodeChanged', node.position
        for (i = k = 0, ref = _net.width; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          for (j = l = 0, ref1 = _net.height; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
            node = (ref2 = _net.nodes[i]) != null ? ref2[j] : void 0;
            if (node == null) {
              continue;
            }
            if (node.state > AStar.NODE_STATE_END && node.state < AStar.NODE_STATE_OBSTACLE) {
              node.state = AStar.NODE_STATE_DEFAULT;
            }
            node.prevNode = null;
            node.neighbours = null;
            this.trigger('nodeChanged', node.position);
          }
        }
        listOpen = [];
        listClose = [];
        stepCount = 0;
        this.finished = false;
        _net.startNode.g = 0;
        _net.startNode.h = parseInt(_net.calcShortestDistance(_net.startNode, _net.endNode));
        this.trigger('nodeChanged', _net.startNode.position);
        return listOpen.push(_net.startNode);
      };
      // run the engine by one step
      this.step = () => {
        if (!this.finished) {
          return _step();
        } else {
          return console.log('It has been finished.');
        }
      };
      // run the engine all the way to finish
      this.run = (fps) => {
        var results;
        if (fps != null) {
          this.fps = fps;
        }
        if (!this.isRunning) {
          this.init();
          this.isRunning = true;
          startTime = Date.now();
          if (fps) {
            return autoStep();
          } else {
            results = [];
            while (!this.finished) {
              results.push(_step());
            }
            return results;
          }
        }
      };
      autoStep = () => {
        if (!this.finished) {
          _step();
          return setTimeout(autoStep, 1000 / this.fps);
        }
      };
      _step = () => {
        var currentNode, i, neighbour, neighbours;
        currentNode = listOpen.shift();
        if (currentNode == null) {
          _end(false);
          return;
        }
        if (currentNode.state !== AStar.NODE_STATE_START) {
          currentNode.state = AStar.NODE_STATE_DETECTED;
          this.trigger('nodeChanged', currentNode.position);
        }
        listClose.push(currentNode);
        recalculateLastNode(currentNode);
        neighbours = _net.getNeighboursOf(currentNode);
        for (i in neighbours) {
          if (!hasProp.call(neighbours, i)) continue;
          neighbour = neighbours[i];
          if (listClose.indexOf(neighbour) > -1) {

          } else if (listOpen.indexOf(neighbour) > -1) {

          } else {
            neighbour.prevNode = currentNode;
            neighbour.id = nodeId++;
            if (neighbour.state !== AStar.NODE_STATE_END) {
              neighbour.state = AStar.NODE_STATE_REACHABLE;
            }
            neighbour.g = currentNode.g + neighbour.calcShortestDistanceTo(currentNode);
            neighbour.h = neighbour.calcShortestDistanceTo(_net.endNode);
            this.trigger('nodeChanged', neighbour.position);
            recalculateLastNode(neighbour);
            listOpen.push(neighbour);
          }
        }
        listOpen.sort(compareNodes);
        // detect end
        if (listOpen[0] === _net.endNode) {
          _net.endNode.state = AStar.NODE_STATE_END;
          this.trigger('nodeChanged', _net.endNode.position);
          traceShortestPath();
          _end(true);
        }
        return stepCount++;
      };
      _end = (success) => {
        this.finished = true;
        this.isRunning = false;
        this.result.success = success;
        this.result.time = Math.round(Date.now() - startTime) + 'ms';
        this.result.step = stepCount;
        return this.trigger('finished', this.result);
      };
      compareNodes = function(node1, node2) {
        var delta;
        delta = node1.f() - node2.f();
        if (delta === 0) {
          // without this step it will shows some random which seems stupid
          delta = node2.id - node1.id;
        }
        return delta;
      };
      recalculateLastNode = (node) => {
        var g0, g1, i, neighbour, neighbours, results;
        neighbours = _net.getNeighboursOf(node);
        results = [];
        for (i in neighbours) {
          if (!hasProp.call(neighbours, i)) continue;
          neighbour = neighbours[i];
          // reached nodes: start node, being reaching, has reached
          if (neighbour.state > AStar.NODE_STATE_DEFAULT && neighbour.state < AStar.NODE_STATE_OBSTACLE && neighbour.state !== AStar.NODE_STATE_END) {
            g0 = node.g;
            g1 = neighbour.g + node.calcShortestDistanceTo(neighbour);
            if (g0 > g1) {
              node.prevNode = neighbour;
              node.g = g1;
              results.push(this.trigger('nodeChanged', node.position));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
      // trace the shortest path and change the state from DETECTED to SHORTEST
      traceShortestPath = () => {
        var middleNode, results;
        middleNode = _net.endNode.prevNode;
        results = [];
        while (middleNode !== _net.startNode) {
          middleNode.state = AStar.NODE_STATE_SHORTEST;
          this.trigger('nodeChanged', middleNode.position);
          results.push(middleNode = middleNode.prevNode);
        }
        return results;
      };
    }

  };

}).call(this);
