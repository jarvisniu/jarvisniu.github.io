// Generated by CoffeeScript 2.1.0
(function() {
  /**
   * NetGrid - a net consists of square blocks.
   * @param w - Width of the grid net.
   * @param h - Height of the grid net.
   * @constructor
   */
  AStar.NetGrid = function(w, h) {
    var _self;
    _self = this;
    this.engine = null;
    this.width = w || 20;
    this.height = h || 10;
    this.count = this.width * this.height;
    this.nodes = [];
    // for engine
    this.startNode = null;
    this.endNode = null;
    // setters
    this.setStart = function(x, y) {
      var node;
      node = this.getNode(x, y);
      if (node.state !== AStar.NODE_STATE_DEFAULT) {
        return;
      }
      if (this.startNode != null) {
        if (this.startNode.position.x === x && this.startNode.position.y === y) {
          return;
        }
        this.startNode.state = AStar.NODE_STATE_DEFAULT;
        this.engine.trigger('nodeChanged', this.startNode.position);
      }
      this.startNode = node;
      node.state = AStar.NODE_STATE_START;
      return this.engine.trigger('nodeChanged', node.position);
    };
    this.setEnd = function(x, y) {
      var node;
      node = this.getNode(x, y);
      if (node.state !== AStar.NODE_STATE_DEFAULT) {
        return;
      }
      if (this.endNode != null) {
        if (this.endNode.position.x === x && this.endNode.position.y === y) {
          return;
        }
        this.endNode.state = AStar.NODE_STATE_DEFAULT;
        this.engine.trigger('nodeChanged', this.endNode.position);
      }
      this.endNode = node;
      node.state = AStar.NODE_STATE_END;
      return this.engine.trigger('nodeChanged', node.position);
    };
    // getters
    this.getNode = function(x, y) {
      var base;
      (base = this.nodes)[x] || (base[x] = []);
      if (this.nodes[x][y] == null) {
        this.nodes[x][y] = new AStar.Node(this);
        this.nodes[x][y].position.x = x;
        this.nodes[x][y].position.y = y;
      }
      return this.nodes[x][y];
    };
    this.getNeighboursOf = function(node) {
      var i, j, k, l, neighbour, ref, ref1, ref2, ref3, x, xFrom, xTo, y, yFrom, yTo;
      if (node.neighbours) {
        return node.neighbours;
      }
      x = node.position.x;
      y = node.position.y;
      xFrom = x - 1;
      xTo = x + 1;
      yFrom = y - 1;
      yTo = y + 1;
      if (xFrom < 0) {
        xFrom = 0;
      }
      if (xFrom > this.width - 1) {
        xFrom = this.width - 1;
      }
      if (xTo < 0) {
        xTo = 0;
      }
      if (xTo > this.width - 1) {
        xTo = this.width - 1;
      }
      if (yFrom < 0) {
        yFrom = 0;
      }
      if (yFrom > this.height - 1) {
        yFrom = this.height - 1;
      }
      if (yTo < 0) {
        yTo = 0;
      }
      if (yTo > this.height - 1) {
        yTo = this.height - 1;
      }
      node.neighbours = [];
      for (i = k = ref = xFrom, ref1 = xTo; ref <= ref1 ? k <= ref1 : k >= ref1; i = ref <= ref1 ? ++k : --k) {
        for (j = l = ref2 = yFrom, ref3 = yTo; ref2 <= ref3 ? l <= ref3 : l >= ref3; j = ref2 <= ref3 ? ++l : --l) {
          neighbour = this.getNode(i, j);
          if (i === x && j === y) {
            // not itself
            continue;
          }
          if (neighbour.state === AStar.NODE_STATE_OBSTACLE) {
            // not obstacle
            continue;
          }
          // When move on the diagonals, four blocks must be all reachable.
          if ((i - x) * (j - y) !== 0) {
            if (this.getNode(x, j).state === AStar.NODE_STATE_OBSTACLE || this.getNode(i, y).state === AStar.NODE_STATE_OBSTACLE) {
              continue;
            }
          }
          node.neighbours.push(neighbour);
        }
      }
      return node.neighbours;
    };
    this.calcShortestDistance = function(node1, node2) {
      var distance, dx, dy;
      dx = Math.abs(node1.position.x - node2.position.x);
      dy = Math.abs(node1.position.y - node2.position.y);
      distance = Math.abs(dx - dy) + Math.min(dx, dy) * 1.414;
      return distance;
    };
    return this;
  };

}).call(this);
