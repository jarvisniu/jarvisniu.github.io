<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>AStar Honeycomb</title>
    <style>
      #toolbar {
        padding-bottom: 8px;
      }
      
    </style>
    <script src="../src/Bu.dev.js"></script>
    <script src="./lib/a-star/AStar.js"></script>
    <script src="./lib/a-star/Node.js"></script>
    <script src="./lib/a-star/Engine.js"></script>
    <script src="./lib/a-star/NetHoneycomb.js"></script>
    <script>
      // net info
      var START_POS = {x: 2, y: 5};
      var END_POS = {x: 13, y: 5};
      
      // rendering config
      var MARGIN = 40.5;
      var GRID_SIZE = 50;
      var GAP_SIZE = 4;
      var GRID_SIZE_X = GRID_SIZE * 1.732 / 2;
      var OFFSET_X = GRID_SIZE_X + GAP_SIZE;
      var OFFSET_Y = OFFSET_X * 1.732 / 2;
      
      // components
      var net = new AStar.NetHoneycomb();
      var engine = new AStar.Engine(net);
      net.engine = engine;
      var renderer;
      
      // shapes
      var hexagonRows = [];
      var lineRows = [];
      var labelGRows = [];
      var labelHRows = [];
      var labelFRows = [];
      var axisTextX = [];
      var axisTextY = [];
      
      // interactive
      var isMouseDown = false;
      var isClearing;
      
      $.ready(init);
      
      function init() {
        net.setStart(START_POS.x, START_POS.y);
        net.setEnd(END_POS.x, END_POS.y);
      
        renderer = new Bu.Renderer({
          container: document.body,
          border: true,
          showKeyPoints: false,
          width: MARGIN * 2 + getCentralX(net.width - 1, net.height - 1) - OFFSET_X / 2,
          height: MARGIN * 2 + getCentralY(net.width - 1, net.height - 1) - OFFSET_Y / 2
        });
        renderer.dom.addEventListener("mousedown", onMouseDown);
        renderer.dom.addEventListener("mousemove", onMouseMove);
        renderer.dom.addEventListener("mouseup", onMouseUp);
      
        // bind events
        $("#btnRun").on("click", function () {
          engine.run();
        });
        $("#btnRunSlowly").on("click", function () {
          engine.run(10);
        });
        $("#btnNextStep").on("click", function () {
          engine.step();
        });
      
        var i, j;
        var xCount = net.width;
        var yCount = net.height;
        var cx, cy;
      
        // add grid hexagons
        for (i = 0; i < xCount; i++) {
          hexagonRows[i] = [];
          for (j = 0; j < yCount; j++) {
            cx = getCentralX(i, j);
            cy = getCentralY(i, j);
            hexagonRows[i][j] = new Bu.Polygon(cx, cy, 6, {
              radius: GRID_SIZE / 2,
              angle: Math.PI / 6
            });
            renderer.append(hexagonRows[i][j]);
          }
        }
      
        // add grid path lines
        for (i = 0; i < xCount; i++) {
          lineRows[i] = [];
          for (j = 0; j < yCount; j++) {
            cx = getCentralX(i, j);
            cy = getCentralY(i, j);
            lineRows[i][j] = new Bu.Line(cx, cy, cx, cy);
            //lineRows[i][j].stroke("rgba(0, 128, 255, 0.5");
            lineRows[i][j].lineWidth = 0.5;
            renderer.append(lineRows[i][j]);
          }
        }
      
        // add grid labels
        for (i = 0; i < xCount; i++) {
          labelGRows[i] = [];
          labelHRows[i] = [];
          labelFRows[i] = [];
      
          for (j = 0; j < yCount; j++) {
            cx = getCentralX(i, j);
            cy = getCentralY(i, j);
            labelGRows[i][j] = new Bu.PointText("",
                    cx - OFFSET_X / 2 + 3,
                    cy,
                    {align: "++"}
            );
            labelHRows[i][j] = new Bu.PointText("",
                    cx + OFFSET_X / 2 - 3,
                    cy,
                    {align: "-+"}
            );
            labelFRows[i][j] = new Bu.PointText("",
                    cx,
                    cy - GRID_SIZE / 4,
                    {align: "00"}
            );
      
            labelGRows[i][j].fillStyle =
                    labelHRows[i][j].fillStyle = "#666";
            labelGRows[i][j].fontFamily =
                    labelHRows[i][j].fontFamily =
                            labelFRows[i][j].fontFamily = "SimSun";
            renderer.append(labelGRows[i][j]);
            renderer.append(labelHRows[i][j]);
            renderer.append(labelFRows[i][j]);
            refreshNode(i, j);
          }
        }
      
        // add axis labels
        for (i = 0; i < xCount; i++) {
          axisTextX[i] = new Bu.PointText(
                  i + 1,
                  getCentralX(i, -1),
                  MARGIN / 2
          );
          renderer.append(axisTextX[i]);
        }
        for (i = 0; i < yCount; i++) {
          axisTextY[i] = new Bu.PointText(
                  i + 1,
                  getCentralX(-1, i),
                  getCentralY(-1, i)
          );
          renderer.append(axisTextY[i]);
        }
      
        engine.on("nodeChanged", function (e) {
          refreshNode(e.x, e.y);
        });
      
        engine.on("finished", function (e) {
          console.log('result: ', e);
          if (!e.success) alert("no solution!");
        });
      }
      
      function refreshNode(i, j) {
        var node = net.getNode(i, j);
      
        var rect = hexagonRows[i][j];
      
        rect.strokeStyle = "gray";
        rect.fillStyle = AStar.getStateColor(node.state);
      
        // draw path with prevNode
        if (node.prevNode) {
          var x = getCentralX(node.prevNode.position.x, node.prevNode.position.y);
          var y = getCentralY(node.prevNode.position.x, node.prevNode.position.y);
          lineRows[i][j].setPoint2(new Bu.Point(x, y));
        }
      
        // set shortest path lineWidth
        if (node.state == AStar.NODE_STATE_SHORTEST || node.state == AStar.NODE_STATE_END)
          lineRows[i][j].lineWidth = 5;
      
        // set text
        if (node.state != AStar.NODE_STATE_OBSTACLE && node.state != AStar.NODE_STATE_DEFAULT) {
          labelGRows[i][j].text = node.g * 10;
          labelHRows[i][j].text = node.h * 10;
          labelFRows[i][j].text = node.f() * 10;
        }
      }
      
      function getPolygon(x, y) {
        return hexagonRows[x][y];
      }
      
      function getCentralX(i, j) {
        return MARGIN + OFFSET_X * i + (OFFSET_X / 2) * j + GRID_SIZE_X / 2;
      }
      
      function getCentralY(i, j) {
        return MARGIN + OFFSET_Y * j + GRID_SIZE_X / 2;
      }
      
      function pixelToIndexX(x, y) {
        return Math.round((x - MARGIN * 0.75) / OFFSET_X - y / OFFSET_Y / 2);
      }
      
      function pixelToIndexY(x, y) {
        return Math.round((y - MARGIN - GRID_SIZE_X / 2) / OFFSET_Y);
      }
      
      function onMouseDown(e) {
        e = renderer.processArgs(e);
      
        isMouseDown = true;
      
        var x = pixelToIndexX(e.offsetX, e.offsetY);
        var y = pixelToIndexY(e.offsetX, e.offsetY);
        if (x < 0 || y < 0 || x >= net.width || y >= net.height) return;
      
        var node = net.getNode(x, y);
      
        // left button
      
        if (node.state == AStar.NODE_STATE_DEFAULT) {
          node.state = AStar.NODE_STATE_OBSTACLE;
          isClearing = false;
        } else if (node.state == AStar.NODE_STATE_OBSTACLE) {
          node.state = AStar.NODE_STATE_DEFAULT;
          isClearing = true;
        }
      
        engine.trigger("nodeChanged", node.position);
      }
      
      function onMouseMove(e) {
        e = renderer.processArgs(e);
      
        if (isMouseDown) {
          var x = pixelToIndexX(e.offsetX, e.offsetY);
          var y = pixelToIndexY(e.offsetX, e.offsetY);
          if (x < 0 || y < 0 || x >= net.width || y >= net.height) return;
      
          var node = net.getNode(x, y);
      
          if (isClearing) {
            if (node.state == AStar.NODE_STATE_OBSTACLE)
              node.state = AStar.NODE_STATE_DEFAULT;
          } else {
            if (node.state == AStar.NODE_STATE_DEFAULT)
              node.state = AStar.NODE_STATE_OBSTACLE;
          }
      
          engine.trigger("nodeChanged", node.position);
        }
      }
      
      function onMouseUp(e) {
        isMouseDown = false;
      }
      
    </script>
  </head>
  <body>
    <div>Click the blocks to add/remove obstacles.</div>
    <div id="toolbar">
      <button id="btnRun">Run</button>
      <button id="btnRunSlowly">Run slowly</button>
      <button id="btnNextStep">Next step</button>
    </div>
  </body>
</html>