// Generated by CoffeeScript 1.10.0
var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Bu.Line = (function(superClass) {
  extend(Line, superClass);

  function Line(p1, p2, p3, p4) {
    this.onPointChange = bind(this.onPointChange, this);
    Line.__super__.constructor.call(this);
    this.type = 'Line';
    if (arguments.length < 2) {
      this.points = [new Bu.Point(), new Bu.Point()];
    } else if (arguments.length < 4) {
      this.points = [p1.clone(), p2.clone()];
    } else {
      this.points = [new Bu.Point(p1, p2), new Bu.Point(p3, p4)];
    }
    this.midpoint = new Bu.Point();
    this.keyPoints = this.points;
    this.onPointChange();
  }

  Line.prototype.onPointChange = function() {
    this.length = this.points[0].distanceTo(this.points[1]);
    return this.midpoint.set((this.points[0].x + this.points[1].x) / 2, (this.points[0].y + this.points[1].y) / 2);
  };

  Line.prototype.set = function(a1, a2, a3, a4) {
    if (typeof p4 !== "undefined" && p4 !== null) {
      this.points[0].set(a1, a2);
      this.points[1].set(a3, a4);
    } else {
      this.points[0] = a1;
      this.points[1] = a2;
    }
    this.onPointChange();
    return this;
  };

  Line.prototype.setPoint1 = function(a1, a2) {
    if (a2 != null) {
      this.points[0].set(a1, a2);
    } else {
      this.points[0].copy(a1);
    }
    this.onPointChange();
    return this;
  };

  Line.prototype.setPoint2 = function(a1, a2) {
    if (a2 != null) {
      this.points[1].set(a1, a2);
    } else {
      this.points[1].copy(a1);
    }
    this.onPointChange();
    return this;
  };

  Line.prototype.isTwoPointsSameSide = function(p1, p2) {
    var pA, pB, y01, y02;
    pA = this.points[0];
    pB = this.points[1];
    if (pA.x === pB.x) {
      return (p1.x - pA.x) * (p2.x - pA.x) > 0;
    } else {
      y01 = (pA.y - pB.y) * (p1.x - pA.x) / (pA.x - pB.x) + pA.y;
      y02 = (pA.y - pB.y) * (p2.x - pA.x) / (pA.x - pB.x) + pA.y;
      return (p1.y - y01) * (p2.y - y02) > 0;
    }
  };

  Line.prototype.distanceTo = function(point) {
    var a, b, p1, p2;
    p1 = this.points[0];
    p2 = this.points[1];
    a = (p1.y - p2.y) / (p1.x - p2.x);
    b = p1.y - a * p1.x;
    return Math.abs(a * point.x + b - point.y) / Math.sqrt(a * a + 1);
  };

  Line.prototype.distanceTo2 = function(point) {
    var a, b, czX, czY, p1, p2;
    p1 = this.points[0];
    p2 = this.points[1];
    a = (p1.y - p2.y) / (p1.x - p2.x);
    b = p1.y - (p1.y - p2.y) * p1.x / (p1.x - p2.x);
    czX = (point.y + point.x / a - b) / (a + 1 / a);
    czY = a * czX + b;
    return Bu.bevel(czX - point.x, czY - point.y);
  };

  Line.prototype.footPointFrom = function(point, footPoint) {
    var A, B, m, p1, p2, x, y;
    p1 = this.points[0];
    p2 = this.points[1];
    A = (p1.y - p2.y) / (p1.x - p2.x);
    B = p1.y - A * p1.x;
    m = point.x + A * point.y;
    x = (m - A * B) / (A * A + 1);
    y = A * x + B;
    if (footPoint != null) {
      return footPoint.set(x, y);
    } else {
      return new Bu.Point(x, y);
    }
  };

  Line.prototype.getCrossPointWith = function(line) {
    var a1, a2, b1, b2, c1, c2, det, p1, p2, q1, q2;
    p1 = this.points[0];
    p2 = this.points[1];
    q1 = line.points[0];
    q2 = line.points[1];
    a1 = p2.y - p1.y;
    b1 = p1.x - p2.x;
    c1 = (a1 * p1.x) + (b1 * p1.y);
    a2 = q2.y - q1.y;
    b2 = q1.x - q2.x;
    c2 = (a2 * q1.x) + (b2 * q1.y);
    det = (a1 * b2) - (a2 * b1);
    return new Bu.Point(((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det);
  };

  Line.prototype.isCrossWithLine = function(line) {
    var d, x0, x1, x2, x3, x4, y0, y1, y2, y3, y4;
    x1 = this.points[0].x;
    y1 = this.points[0].y;
    x2 = this.points[1].x;
    y2 = this.points[1].y;
    x3 = line.points[0].x;
    y3 = line.points[0].y;
    x4 = line.points[1].x;
    y4 = line.points[1].y;
    d = (y2 - y1) * (x4 - x3) - (y4 - y3) * (x2 - x1);
    if (d === 0) {
      return false;
    } else {
      x0 = ((x2 - x1) * (x4 - x3) * (y3 - y1) + (y2 - y1) * (x4 - x3) * x1 - (y4 - y3) * (x2 - x1) * x3) / d;
      y0 = ((y2 - y1) * (y4 - y3) * (x3 - x1) + (x2 - x1) * (y4 - y3) * y1 - (x4 - x3) * (y2 - y1) * y3) / -d;
    }
    return (x0 - x1) * (x0 - x2) < 0 && (x0 - x3) * (x0 - x4) < 0 && (y0 - y1) * (y0 - y2) < 0 && (y0 - y3) * (y0 - y4) < 0;
  };

  Line.prototype.isCrossWithLine2 = function(line) {
    var da, db, dx, dy, p1, p2, q1, q2, s, t;
    p1 = this.points[0];
    p2 = this.points[1];
    q1 = line.points[0];
    q2 = line.points[1];
    dx = p2.x - p1.x;
    dy = p2.y - p1.y;
    da = q2.x - q1.x;
    db = q2.y - q1.y;
    if (da * dy - db * dx === 0) {
      return false;
    }
    s = (dx * (q1.y - p1.y) + dy * (p1.x - q1.x)) / (da * dy - db * dx);
    t = (da * (p1.y - q1.y) + db * (q1.x - p1.x)) / (db * dx - da * dy);
    return s >= 0 && s <= 1 && t >= 0 && t <= 1;
  };

  return Line;

})(Bu.Object2D);

//# sourceMappingURL=Line.js.map
