// Generated by CoffeeScript 1.10.0
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Bu.Spline = (function(superClass) {
  var calcControlPoints;

  extend(Spline, superClass);

  function Spline(vertices) {
    var polyline;
    Spline.__super__.constructor.call(this);
    this.type = 'Spline';
    if (vertices instanceof Bu.Polyline) {
      polyline = vertices;
      this.vertices = polyline.vertices;
      polyline.on('pointChange', (function(_this) {
        return function(polyline) {
          _this.vertices = polyline.vertices;
          return calcControlPoints(_this);
        };
      })(this));
    } else {
      this.vertices = Bu.clone(vertices);
    }
    this.keyPoints = this.vertices;
    this.controlPointsAhead = [];
    this.controlPointsBehind = [];
    this.smooth = Bu.DEFAULT_SPLINE_SMOOTH;
    calcControlPoints(this);
  }

  Spline.prototype.clone = function() {
    return new Bu.Spline(this.vertices);
  };

  Spline.prototype.addPoint = function(point) {
    this.vertices.push(point);
    return calcControlPoints(this);
  };

  calcControlPoints = function(spline) {
    var i, j, len, len1, len2, ref, results, theta, theta1, theta2, vertices, xA, xB, yA, yB;
    spline.keyPoints = spline.vertices;
    vertices = spline.vertices;
    len = vertices.length;
    if (len >= 1) {
      spline.controlPointsBehind[0] = vertices[0];
    }
    if (len >= 2) {
      spline.controlPointsAhead[len - 1] = vertices[len - 1];
    }
    if (len >= 3) {
      results = [];
      for (i = j = 1, ref = len - 1; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        theta1 = Math.atan2(vertices[i].y - vertices[i - 1].y, vertices[i].x - vertices[i - 1].x);
        theta2 = Math.atan2(vertices[i + 1].y - vertices[i].y, vertices[i + 1].x - vertices[i].x);
        theta = (theta2 + theta1) / 2;
        if (Math.abs(theta - theta1) > Math.PI / 2) {
          theta += Math.PI;
        }
        len1 = Bu.bevel(vertices[i].y - vertices[i - 1].y, vertices[i].x - vertices[i - 1].x);
        len2 = Bu.bevel(vertices[i].y - vertices[i + 1].y, vertices[i].x - vertices[i + 1].x);
        xA = vertices[i].x - len1 * spline.smooth * Math.cos(theta);
        yA = vertices[i].y - len1 * spline.smooth * Math.sin(theta);
        xB = vertices[i].x + len2 * spline.smooth * Math.cos(theta);
        yB = vertices[i].y + len2 * spline.smooth * Math.sin(theta);
        spline.controlPointsAhead[i] = new Bu.Point(xA, yA);
        results.push(spline.controlPointsBehind[i] = new Bu.Point(xB, yB));
      }
      return results;
    }
  };

  return Spline;

})(Bu.Object2D);

//# sourceMappingURL=Spline.js.map
