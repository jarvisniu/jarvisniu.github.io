// Generated by CoffeeScript 1.10.0
var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Bu.Polyline = (function(superClass) {
  var set;

  extend(Polyline, superClass);

  function Polyline(vertices1) {
    var i, j, ref, vertices;
    this.vertices = vertices1 != null ? vertices1 : [];
    this.calcLength = bind(this.calcLength, this);
    this.updateLines = bind(this.updateLines, this);
    this.clone = bind(this.clone, this);
    Polyline.__super__.constructor.call(this);
    this.type = 'Polyline';
    if (arguments.length > 1) {
      vertices = [];
      for (i = j = 0, ref = arguments.length / 2; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        vertices.push(new Bu.Point(arguments[i * 2], arguments[i * 2 + 1]));
      }
      this.vertices = vertices;
    }
    this.lines = [];
    this.length = 0;
    this.pointNormalizedPos = [];
    this.keyPoints = this.vertices;
    this.on("pointChange", (function(_this) {
      return function() {
        if (_this.vertices.length > 1) {
          _this.updateLines();
          _this.calcLength();
          return _this.calcPointNormalizedPos();
        }
      };
    })(this));
    this.trigger("pointChange", this);
  }

  Polyline.prototype.clone = function() {
    return new Bu.Polyline(this.vertices);
  };

  Polyline.prototype.updateLines = function() {
    var i, j, ref, results;
    results = [];
    for (i = j = 0, ref = this.vertices.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (this.lines[i] != null) {
        results.push(this.lines[i].set(this.vertices[i], this.vertices[i + 1]));
      } else {
        results.push(this.lines[i] = new Bu.Line(this.vertices[i], this.vertices[i + 1]));
      }
    }
    return results;
  };

  Polyline.prototype.calcLength = function() {
    var i, j, len, ref;
    if (this.vertices.length < 2) {
      return this.length = 0;
    } else {
      len = 0;
      for (i = j = 1, ref = this.vertices.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        len += this.vertices[i].distanceTo(this.vertices[i - 1]);
      }
      return this.length = len;
    }
  };

  Polyline.prototype.calcPointNormalizedPos = function() {
    var currPos, i, j, ref, results;
    currPos = 0;
    this.pointNormalizedPos[0] = 0;
    results = [];
    for (i = j = 1, ref = this.vertices.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
      currPos += this.vertices[i].distanceTo(this.vertices[i - 1]) / this.length;
      results.push(this.pointNormalizedPos[i] = currPos);
    }
    return results;
  };

  Polyline.prototype.getNormalizedPos = function(index) {
    if (index != null) {
      return this.pointNormalizedPos[index];
    } else {
      return this.pointNormalizedPos;
    }
  };

  set = function(points) {
    var i, j, ref;
    for (i = j = 0, ref = this.vertices.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      this.vertices[i].copy(points[i]);
    }
    if (this.vertices.length > points.length) {
      this.vertices.splice(points.length);
    }
    return this.trigger("pointChange", this);
  };

  Polyline.prototype.addPoint = function(point, insertIndex) {
    if (insertIndex == null) {
      this.vertices.push(point);
      if (this.vertices.length > 1) {
        this.lines.push(new Bu.Line(this.vertices[this.vertices.length - 2], this.vertices[this.vertices.length - 1]));
      }
    } else {
      this.vertices.splice(insertIndex, 0, point);
    }
    return this.trigger("pointChange", this);
  };

  return Polyline;

})(Bu.Object2D);

//# sourceMappingURL=Polyline.js.map
