// Generated by CoffeeScript 1.10.0
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Bu.Point = (function(superClass) {
  var footPoint;

  extend(Point, superClass);

  function Point(x1, y1) {
    this.x = x1 != null ? x1 : 0;
    this.y = y1 != null ? y1 : 0;
    Point.__super__.constructor.call(this);
    this.type = 'Point';
    this.lineWidth = 0.5;
    this._labelIndex = -1;
  }

  Point.prototype.clone = function() {
    return new Bu.Point(this.x, this.y);
  };

  Point.property('label', {
    get: function() {
      if (this._labelIndex > -1) {
        return this.children[this._labelIndex].text;
      } else {
        return '';
      }
    },
    set: function(val) {
      var pointText;
      if (this._labelIndex === -1) {
        pointText = new Bu.PointText(val, this.x + Bu.POINT_LABEL_OFFSET, this.y, {
          align: '+0'
        });
        this.children.push(pointText);
        return this._labelIndex = this.children.length - 1;
      } else {
        return this.children[this._labelIndex].text = val;
      }
    }
  });

  Point.prototype.arcTo = function(radius, arc) {
    return new Bu.Point(this.x + Math.cos(arc) * radius, this.y + Math.sin(arc) * radius);
  };

  Point.prototype.copy = function(point) {
    this.x = point.x;
    this.y = point.y;
    return this.updateLabel();
  };

  Point.prototype.set = function(x, y) {
    this.x = x;
    this.y = y;
    return this.updateLabel();
  };

  Point.prototype.updateLabel = function() {
    if (this._labelIndex > -1) {
      this.children[this._labelIndex].x = this.x + Bu.POINT_LABEL_OFFSET;
      return this.children[this._labelIndex].y = this.y;
    }
  };

  Point.prototype.distanceTo = function(point) {
    return Bu.bevel(this.x - point.x, this.y - point.y);
  };

  footPoint = null;

  Point.prototype.isNear = function(target, limit) {
    var i, isBetween1, isBetween2, len, line, ref, verticalDist;
    if (limit == null) {
      limit = Bu.DEFAULT_NEAR_DIST;
    }
    switch (target.type) {
      case 'Point':
        return this.distanceTo(target) < limit;
      case 'Line':
        verticalDist = target.distanceTo(this);
        if (footPoint == null) {
          footPoint = new Bu.Point;
        }
        target.footPointFrom(this, footPoint);
        isBetween1 = footPoint.distanceTo(target.points[0]) < target.length + Bu.DEFAULT_NEAR_DIST;
        isBetween2 = footPoint.distanceTo(target.points[1]) < target.length + Bu.DEFAULT_NEAR_DIST;
        return verticalDist < limit && isBetween1 && isBetween2;
      case 'Polyline':
        ref = target.lines;
        for (i = 0, len = ref.length; i < len; i++) {
          line = ref[i];
          if (this.isNear(line)) {
            return true;
          }
        }
        return false;
    }
  };

  return Point;

})(Bu.Object2D);

Bu.Point.interpolate = function(p1, p2, k, p3) {
  var x, y;
  x = p1.x + (p2.x - p1.x) * k;
  y = p1.y + (p2.y - p1.y) * k;
  if (p3 != null) {
    return p3.set(x, y);
  } else {
    return new Bu.Point(x, y);
  }
};

//# sourceMappingURL=Point.js.map
