// Generated by CoffeeScript 1.10.0

/*
 * MicroJQuery - A micro version of jQuery
 *
 * Supported features:
 *   $. - static methods
 *     .ready(cb) - call the callback function after the page is loaded
 *     .ajax([url,] options) - perform an ajax request
 *   $(selector) - select element(s)
 *     .on(type, callback) - add an event listener
 *     .off(type, callback) - remove an event listener
 *     .append(tagName) - append a tag
 *     .text(text) - set the inner text
 *     .html(htmlText) - set the inner HTML
 *     .style(name, value) - set style (a css attribute)
 *     #.css(object) - set styles (multiple css attribute)
 *     .hasClass(className) - detect whether a class exists
 *     .addClass(className) - add a class
 *     .removeClass(className) - remove a class
 *     .toggleClass(className) - toggle a class
 *     .attr(name, value) - set an attribute
 *     .hasAttr(name) - detect whether an attribute exists
 *     .removeAttr(name) - remove an attribute
 *   Notes:
 *        # is planned but not implemented
 */
(function(global) {
  var jQuery;
  global.$ = function(selector) {
    var selections;
    selections = [];
    if (typeof selector === 'string') {
      selections = [].slice.call(document.querySelectorAll(selector));
    }
    jQuery.apply(selections);
    return selections;
  };
  jQuery = function() {
    var SVG_TAGS;
    this.on = (function(_this) {
      return function(type, callback) {
        _this.each(function(dom) {
          return dom.addEventListener(type, callback);
        });
        return _this;
      };
    })(this);
    this.off = (function(_this) {
      return function(type, callback) {
        _this.each(function(dom) {
          return dom.removeEventListener(type, callback);
        });
        return _this;
      };
    })(this);
    SVG_TAGS = 'svg line rect circle ellipse polyline polygon path text';
    this.append = (function(_this) {
      return function(tag) {
        _this.each(function(dom, i) {
          var newDom, tagIndex;
          tagIndex = SVG_TAGS.indexOf(tag.toLowerCase());
          if (tagIndex > -1) {
            newDom = document.createElementNS('http://www.w3.org/2000/svg', tag);
          } else {
            newDom = document.createElement(tag);
          }
          return _this[i] = dom.appendChild(newDom);
        });
        return _this;
      };
    })(this);
    this.text = (function(_this) {
      return function(str) {
        _this.each(function(dom) {
          return dom.textContent = str;
        });
        return _this;
      };
    })(this);
    this.html = (function(_this) {
      return function(str) {
        _this.each(function(dom) {
          return dom.innerHTML = str;
        });
        return _this;
      };
    })(this);
    this.style = (function(_this) {
      return function(name, value) {
        _this.each(function(dom) {
          var i, styleText, styles;
          styleText = dom.getAttribute('style');
          styles = {};
          if (styleText) {
            styleText.split(';').each(function(n) {
              var nv;
              nv = n.split(':');
              return styles[nv[0]] = nv[1];
            });
          }
          styles[name] = value;
          styleText = '';
          for (i in styles) {
            styleText += i + ': ' + styles[i] + '; ';
          }
          return dom.setAttribute('style', styleText);
        });
        return _this;
      };
    })(this);
    this.hasClass = (function(_this) {
      return function(name) {
        var classText, classes, i;
        if (_this.length === 0) {
          return false;
        }
        i = 0;
        while (i < _this.length) {
          classText = _this[i].getAttribute('class' || '');
          classes = classText.split(RegExp(' +'));
          if (!classes.contains(name)) {
            return false;
          }
          i++;
        }
        return _this;
      };
    })(this);
    this.addClass = (function(_this) {
      return function(name) {
        _this.each(function(dom) {
          var classText, classes;
          classText = dom.getAttribute('class' || '');
          classes = classText.split(RegExp(' +'));
          if (!classes.contains(name)) {
            classes.push(name);
            return dom.setAttribute('class', classes.join(' '));
          }
        });
        return _this;
      };
    })(this);
    this.removeClass = (function(_this) {
      return function(name) {
        _this.each(function(dom) {
          var classText, classes;
          classText = dom.getAttribute('class') || '';
          classes = classText.split(RegExp(' +'));
          if (classes.contains(name)) {
            classes.remove(name);
            if (classes.length > 0) {
              return dom.setAttribute('class', classes.join(' '));
            } else {
              return dom.removeAttribute('class');
            }
          }
        });
        return _this;
      };
    })(this);
    this.toggleClass = (function(_this) {
      return function(name) {
        _this.each(function(dom) {
          var classText, classes;
          classText = dom.getAttribute('class' || '');
          classes = classText.split(RegExp(' +'));
          if (classes.contains(name)) {
            classes.remove(name);
          } else {
            classes.push(name);
          }
          if (classes.length > 0) {
            return dom.setAttribute('class', classes.join(' '));
          } else {
            return dom.removeAttribute('class');
          }
        });
        return _this;
      };
    })(this);
    this.attr = (function(_this) {
      return function(name, value) {
        if (value != null) {
          _this.each(function(dom) {
            return dom.setAttribute(name, value);
          });
          return _this;
        } else {
          return _this[0].getAttribute(name);
        }
      };
    })(this);
    this.hasAttr = (function(_this) {
      return function(name) {
        var i;
        if (_this.length === 0) {
          return false;
        }
        i = 0;
        while (i < _this.length) {
          if (!_this[i].hasAttribute(name)) {
            return false;
          }
          i++;
        }
        return _this;
      };
    })(this);
    this.removeAttr = (function(_this) {
      return function(name) {
        _this.each(function(dom) {
          return dom.removeAttribute(name);
        });
        return _this;
      };
    })(this);
    return this.val = (function(_this) {
      return function() {
        var ref;
        return (ref = _this[0]) != null ? ref.value : void 0;
      };
    })(this);
  };
  global.$.ready = function(onLoad) {
    return document.addEventListener('DOMContentLoaded', onLoad);
  };

  /* $.ajax()
  		options:
  			url: string
  			====
  			async = true: bool
  			## data: object - query parameters TODO: implement this
  			method = GET: POST, PUT, DELETE, HEAD
  			username: string
  			password: string
  			success: function
  			error: function
  			complete: function
   */
  return global.$.ajax = function(url, ops) {
    var xhr;
    if (!ops) {
      if (typeof url === 'object') {
        ops = url;
        url = ops.url;
      } else {
        ops = {};
      }
    }
    ops.method || (ops.method = 'GET');
    if (ops.async == null) {
      ops.async = true;
    }
    xhr = new XMLHttpRequest;
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          if (ops.success != null) {
            return ops.success(xhr.responseText, xhr.status, xhr);
          }
        } else {
          if (ops.error != null) {
            ops.error(xhr, xhr.status);
          }
          if (ops.complete != null) {
            return ops.complete(xhr, xhr.status);
          }
        }
      }
    };
    xhr.open(ops.method, url, ops.async, ops.username, ops.password);
    return xhr.send(null);
  };
})(window || this);

//# sourceMappingURL=MicroJQuery.js.map
