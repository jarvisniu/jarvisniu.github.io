/*********************************************************************
 * Author: BJ Niu
 * Date: 2014/01/19
 * Describe: You must have define a WebGL context named: gl.
 *
 * =========== Change Log ===========
 *
 * v1.0
 *      - first release
 *
 * v1.3 - 2014/01/19
 *      - add gl.enable(gl.CULL_FACE)
 *      - add createTexture(img)
 *
 * v1.4 - 2014/10/08
 *      - remove mvMatrixStack
 *
 * plan
 *      - allow addTask(func, arg1, arg2, ...)
 *
 *********************************************************************
 */

var mvMatrix = mat4.create();
var pMatrix = mat4.create();
var _canvas = null;


function initGL(canvasID) {
    var canvas = (typeof(canvasID) == "string") ? document.getElementById(canvasID) : canvasID;
    _canvas = canvas;
    try {
        var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight); //设置视见区（摄像机）
        gl.clearColor(0.0, 0.0, 0.0, 1.0); //设置背景色为黑色
        gl.enable(gl.DEPTH_TEST);           //开启深度检测功能，否则将没有遮挡效果
        // gl.depthFunc(gl.LEQUAL);
        // gl.depthFunc(gl.LESS);
        // gl.enable(gl.CULL_FACE);
        //gl.clearColor(0.2, 0.0, 0.2, 1.0); //设置背景色为深紫色
    } catch (e) {}
    if (!gl) {
        alert("Unable to initialize WebGL. Your browser may not support it.");
        gl = null;
    }
    return gl;
}

function clearGL() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); //清空
}
function clearGlDepth() {
    gl.clear(gl.DEPTH_BUFFER_BIT); //清空
}

function updateViewport(){
    gl.viewportWidth = _canvas.width;
    gl.viewportHeight = _canvas.height;
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight); //设置视见区（摄像机）
}
//更改设置
function setAlpha(alphaOn){
    if (alphaOn) {
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE); //正常的混合方式
        //gl.blendFunc(gl.ONE,gl.DST_ALPHA); //段老师的混合方式
        gl.enable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
    } else {
        gl.disable(gl.BLEND);
        gl.clearDepth(1.0);
        gl.disable(gl.BLEND);
        gl.enable(gl.DEPTH_TEST);           //开启深度检测功能，否则将没有遮挡效果
    }
}

//gl
function loadShaderProgram(fileName) {
    var programInfo = JSON.parse(loadUrl(fileName));
    //alert(JSON.stringify(programInfo));
    var vertexFileName = getFilePath(fileName) + programInfo.vertex + ".vsh";
    var fragmentFileName = getFilePath(fileName) + programInfo.fragment + ".fsh";

    var fragmentShader = loadShader(fragmentFileName);
    var vertexShader = loadShader(vertexFileName);

    var program = gl.createProgram();
    program.Info = programInfo;
    gl.attachShader(program, fragmentShader);
    gl.attachShader(program, vertexShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
    }


    for (var i = 0; i < programInfo.attributes.length; i++) {
        program[programInfo.attributes[i]["name"]] = gl.getAttribLocation(program, programInfo.attributes[i]["name"]);
        gl.enableVertexAttribArray(program[programInfo.attributes[i]["name"]]);
    }

    for (var i = 0; i < programInfo.uniforms.length; i++) {
        program[programInfo.uniforms[i]["name"]] = gl.getUniformLocation(program, programInfo.uniforms[i]["name"]);
    }

    gl.useProgram(program);
    return program;
}

//gl
function loadShader(fileName) {
    var shader;
    if (fileName.indexOf(".fsh") > 0) {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (fileName.indexOf(".vsh") > 0) {
        shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
        return null;
    }

    gl.shaderSource(shader, loadUrl(fileName));
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
}

//Texture

function loadBlankTexture() {
    return gl.createTexture();
}

function createTexture(img) {
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.bindTexture(gl.TEXTURE_2D, null);
    return texture;
}

function loadTexture(url) {
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
        new Uint8Array([86, 110, 82, 255])); // green
    var image = new Image();
    image.onload = function() {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
    };
    if (url.length > 5) image.src = url;
    return texture;
}

function setMatrixUniforms(program) {	// to abandon
    gl.uniformMatrix4fv(program.uPMatrix, false, pMatrix);
    gl.uniformMatrix4fv(program.uMVMatrix, false, mvMatrix);
}

function createVertexPositionBuffer(data) {
    return createArrayBuffer(data, 3);
}

function createVertexColorBuffer(data) {
    return createArrayBuffer(data, 4);
}

function createVertexTextureCoordBuffer(data) {
    return createArrayBuffer(data, 2);
}

function createVertexIndexBuffer(data) {
    return createElementBuffer(data);
}

//private
function createArrayBuffer(data, itemSize) {
    var buffer = gl.createBuffer(); //创建缓存器
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer); //将缓存器绑定到WebGL上
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW); //将数据加入到缓存器内
    buffer.itemSize = itemSize;
    buffer.numItems = data.length / buffer.itemSize;
    buffer.data = data;
    return buffer;
}

function createElementBuffer(data) {
    var buffer = gl.createBuffer(); //创建缓存器
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); //将缓存器绑定到WebGL上
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), gl.STATIC_DRAW); //将数据加入到缓存器内
    buffer.itemSize = 1;
    buffer.numItems = data.length / buffer.itemSize;
    buffer.data = data;
    return buffer;
}

//以下为动画功能，用户可以定义anim或animate函数来生成动画，该函数会被自行调用
var lastTime = 0;

function tick() {
//    console.log("ticking...");
    // animate
    animateTick();

    // handleKeys
    if ('handleKeys' in window) handleKeys();

    // drawScene
    if ('drawScene' in window)
        drawScene();
    else {
        alert("未找到关键函数: drawScene()，Canvas内将不会显示任何内容。");
        return;
    }

    // next frame
    requestAnimFrame(tick);
}

window.requestAnimFrame = (function() {
    return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback, element) {
            window.setTimeout(callback, 1000 / 60);
        };
})();

function animateTick() {
    var timeNow = new Date().getTime();
    if (lastTime != 0) {
        var elapsed = timeNow - lastTime;

        if ('anim' in window) anim(elapsed);
        if ('animate' in window) animate(elapsed);
    }
    lastTime = timeNow;
}