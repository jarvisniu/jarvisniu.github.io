/**
 * BjCvsMap-1.0
 * 地图显示引擎
 *
 *
 * 依赖 Dependence
 * ==============
 *
 * TileProvider(1.1-1.2, NOT 1.3)
 *
 *
 * 功能 Features
 * ============
 *
 * 1. 分级显示地图
 * 2. 多边形绘制
 * 3.
 *
 * ========================  Change Log  ==============================
 *
 *     v1.0.0
 *
 *         1. first release
 *
 *
 *     v1.0.1
 *
 *         1. sync to TileProvider
 *
 *
 * 计划 Plan
 * ========
 *
 * - 封装成模块
 * - 更名为 BjMap
 *
 */

// map environment
var level = 16;  // 初始缩放等级
var initCoord = { lat: 39.9158, lon: 116.3908 };  // 初始经纬度：紫禁城
var cIndex;
var zoomFactor = 1;  // zoom factor, from 0.5 to 1, used to generate smooth zoom animation.
var isZooming = 0;
var cvs, ctx, cvsW, cvsH, halfW, halfH, tileNumW, tileNumH;
var tileGetter;
var mousePos = { X: -1, Y: -1, GX: -1, GY: -1, Lng: -1, Lat: -1, DotIndex: -1, LineIndex: -1 };
var mouseDown = { X: 0, Y: 0, Button: -1, MovLength: 0 };
var indexSelectedPoint = -1;
var lastZoomTime = 0;
// settings
var isZoomingSmooth = true;

function initCvsMap() {
    //debug

    // set uniform vars
    cIndex = {
        X: lon2index(initCoord.lon, level),
        Y: lat2index(initCoord.lat, level)
    };
    cvs = document.getElementsByTagName("canvas")[0];
    ctx = cvs.getContext("2d");
    ctx.textBaseline = "top";
    ctx.font = "13px SimSun";
    cvsW = cvs.width; cvsH = cvs.height;
    halfW = cvsW / 2; halfH = cvsH / 2;
    tileNumW = Math.ceil(cvsW / 256) + 2; tileNumH = Math.ceil(cvsH / 256) + 2;

    if (!("TileProvider" in window)) console.error("未找到TileProvider类，请检查是否未引用该库文件。");
    tileGetter = new TileProvider();
    tileGetter.set({
        source: MapSource.BING // 注释掉此句以使用Google Maps（但需要翻墙）
    });
    tileGetter.onProgress = drawCanvas;
    
    // bind event handlers
    cvs.addEventListener("mousemove", onMouseMove);
    cvs.addEventListener("mousedown", onMouseDown);
    cvs.addEventListener("mouseup", onMouseUp);
    cvs.addEventListener("mousewheel", onMouseWheel);

    setTimeout(drawCanvas, 100);
}
document.addEventListener("DOMContentLoaded", initCvsMap);

// Drawing functions
function drawCanvas() {
    ctx.clearRect(0, 0, cvsW, cvsH);
    drawTiles();
    drawLevelInfo();
    drawMouseInfo();
}

function drawTiles() {
    var xFrom = parseInt(cIndex.X - tileNumW / 2);
    var xTo = xFrom + tileNumW;
    var yFrom = parseInt(cIndex.Y - tileNumH / 2);
    var yTo = yFrom + tileNumH;
    for(var i = xFrom; i <= xTo; i++) {
        for( var j = yFrom; j <= yTo; j++) {
            drawTile(i, j, level);
        }
    }
}

function drawTile(x, y, z) {
    var drawPos = {X: halfW, Y: halfH};
    drawPos.X += (x - cIndex.X) * 256 * zoomFactor;
    drawPos.Y += (y - cIndex.Y) * 256 * zoomFactor;
    var img = tileGetter.getDom(x, y, z);
    ctx.drawImage(img, drawPos.X, drawPos.Y, 256 * zoomFactor, 256 * zoomFactor);
}

function drawLevelInfo() {
    ctx.strokeStyle = "rgb(0, 0, 0)";
    ctx.strokeRect(8, 8, 80, 18);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.fillRect(8, 8, 80, 18);
    ctx.fillStyle = "#222";
    ctx.fillText("Level = " + level, 13, 11);
}

function drawMouseInfo() {
    ctx.strokeStyle = "rgb(0, 0, 0)";
    ctx.strokeRect(mousePos.X, mousePos.Y + 20, 188, 17);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.fillRect(mousePos.X, mousePos.Y + 20, 188, 17);
    ctx.fillStyle = "#222";
    ctx.fillText("X：" + r5(mousePos.Lng), mousePos.X + 4, mousePos.Y + 22);
    ctx.fillText("Y：" + r5(mousePos.Lat), mousePos.X + 100, mousePos.Y + 22);
}

// Mouse event functions
function onMouseMove(e) {
    mousePos.X = e.offsetX;
    mousePos.Y = e.offsetY;
    mousePos.Lng = index2lon(mousePos.GX, level, 6);
    mousePos.Lat = index2lat(mousePos.GY, level, 6);
    mousePos.GX = cIndex.X + (mousePos.X - halfW) / 256;
    mousePos.GY = cIndex.Y + (mousePos.Y - halfH) / 256;

    if (mouseDown.Button == 0) {
        var deltaX = mousePos.X - mouseDown.X;
        var deltaY = mousePos.Y - mouseDown.Y;
        if(mousePos.DotIndex == -1) {
            cIndex.X -= deltaX / 256;
            cIndex.Y -= deltaY / 256;
            mouseDown.MovLength += Math.abs(deltaX) + Math.abs(deltaY);
        }
    } else if (mouseDown.Button == 1) {
        mouseDown.MovLength += Math.abs(deltaX) + Math.abs(deltaY);
        
    } else if (mouseDown.Button == 2) {
        mouseDown.MovLength += Math.abs(deltaX) + Math.abs(deltaY);
        
    }

    // cursor
    if(mousePos.DotIndex == -1 && mousePos.LineIndex == -1) {
        cvs.style.cursor = "default";
    } else {
        cvs.style.cursor = "hand";
    }
    mouseDown.X = e.offsetX;
    mouseDown.Y = e.offsetY;
    drawCanvas();
}

function onMouseDown(e) {
    mouseDown.Button = e.button;

    if(mousePos.DotIndex == -1) {
        if (mousePos.LineIndex > -1) {
            mousePos.DotIndex = mousePos.LineIndex + 1;
            addPoint(mousePos.Lng, mousePos.Lat, mousePos.LineIndex + 1);
            drawCanvas();
        }   
    }
}

function onMouseUp(e) {
    mouseDown.Button = -1;
    mouseDown.MovLength = 0;
}

function onMouseWheel(e) {
    // 左键未移动松开
    if (e.wheelDelta > 0) {
        if (isZoomingSmooth)
            zoomInSmooth();
        else
            zoomIn();
    } else {
        if (isZoomingSmooth)
            zoomOutSmooth();
        else
            zoomOut();
    }
}

function navigateTo(lat, lon) {
    var x = lon2index(lon, level);
    var y = lat2index(lat, level);
    cIndex.X = x;
    cIndex.Y = y;
    //alert(cIndex.X+"\n"+cIndex.Y);
    drawCanvas();
}

// GeoMath
function gX2DrawX(gx) {
    return halfW + (gx - cIndex.X) * 256 * zoomFactor;
}

function gY2DrawY(gy) {
    return halfH + (gy - cIndex.Y) * 256 * zoomFactor;
}

function drawX2gX(drawX) {
    return (drawX - halfW) / 256 + cIndex.X;
}

function drawY2gY(drawY) {
    return (drawY - halfH) / 256 + cIndex.Y;
}

function isPointOnLine(x, y, p1x, p1y, p2x, p2y) {
    var a = (p1y - p2y) / (p1x - p2x);
    var b = p1y - (p1y - p2y) * p1x / (p1x - p2x);
    var czX = (y + x / a - b) / (a + 1 / a);
    var czY = a * czX + b;
    var len1 = bevel(czX - x, czY - y);
    var cp = centralP(p1x, p1y, p2x, p2y);
    var k = (p2y - p1y) / (p2x - p1x);
    var len2 = p2l_pk(x, y, cp[0], cp[1], -1 / k);
    return (len1 < 5 && len2 * 2 < bevel(p2y - p1y, p2x - p1x));
}

function p2l_2p(x, y, p1x, p1y, p2x, p2y) {
    var a = (p1y - p2y) / (p1x - p2x);
    var b = p1y - (p1y - p2y) * p1x / (p1x - p2x);
    var czX = (y + x / a - b) / (a + 1 / a);
    var czY = a * czX + b;
    return bevel(czX - x, czY - y);
}

function p2l_kb(x, y, k, b) {
    var czX = (y + x / k - b) / (k + 1 / k);
    var czY = (k * y + x + b / k) / (k + 1 / k);
    return bevel(czX - x, czY - y);
}

function p2l_pk(x, y, x0, y0, k) {
    var czX = (y + x / k + k * x0 - y0) / (k + 1 / k);
    var czY = (k * y + x + k * k * x0 - y0 * k) / (k + 1 / k) - k * x0 + y0;
    return bevel(czX - x, czY - y);
}

function bevel(x, y) {
    return Math.sqrt(x*x + y*y);
}

function centralP(x1, y1, x2, y2) {
    return [(x1 + x2) / 2, (y1 + y2) / 2];
}

function zoomOutSmooth() {
    if (level > 0 && canZoomNow()) {
        if (isZooming == 1) return;
        isZooming = -1;
        zoomFactor *= 0.95;

        if (zoomFactor > 0.5)
            setTimeout(zoomOutSmooth, 90);
        else {
            zoomFactor = 1;
            isZooming = 0;
            level --;
            cIndex.X /= 2;
            cIndex.Y /= 2;
        }

        drawCanvas();
    }
}

function zoomInSmooth() {
    if (level < 21 && canZoomNow()) {
        if (isZooming == -1) return;
        isZooming = 1;
        zoomFactor /= 0.95;

        if (zoomFactor < 2)
            setTimeout(zoomInSmooth, 90);
        else {
            zoomFactor = 1;
            isZooming = 0;
            level ++;
            cIndex.X *= 2;
            cIndex.Y *= 2;
        }

        drawCanvas();
    }
}

function zoomOut() {
    if (level > 0 && canZoomNow()) {
        level --;
        cIndex.X /= 2;
        cIndex.Y /= 2;
        drawCanvas();
    }
}

function zoomIn() {
    if (level < 21 && canZoomNow()) {
        level ++;
        cIndex.X *= 2;
        cIndex.Y *= 2;
        drawCanvas();
    }
}

var lastZoomLevel = 0;
function canZoomNow() {
    if (lastZoomLevel == level) return true;

    var currentTime = Date.now();
    if (currentTime - lastZoomTime < 400) {
        return false;
    } else {
        lastZoomLevel = level;
        lastZoomTime = currentTime;
        return true;
    }
}
